const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const rimraf = require('rimraf');
const cpy = require('cpy');
const { quote } = require('shell-quote');

function root(...segments) {
  return path.join(__dirname, '..', ...segments);
}

function q(s) {
  return quote([s]);
}

module.exports = async function createReactProject(options) {
  // Prevent writing to non-empty directory if flag "--force" HAS NOT been set.
  if (!options.force && fs.existsSync(options.out)) {
    throw new Error(`Cannot write files to non-empty directory ${q(path.resolve(options.out))}`);
  }

  // Copy template directories to output.
  for (const dir of [".vscode", "babel", "pages", "public", "scripts", "src", "typings"]) {
    // "-P" don't allow symbolic links
    execSync(`cp -R -P ${root(`template/${dir}`)} ${q(options.out)}`, {stdio: 'inherit'});
  }

  // Copy top-level files from template dir.
  await cpy([
    root('template/*'), root('template/.*')], options.out, {
    // Make sure we will copy top-level files only.
      expandDirectories: false,
      // Ignore paths specified in gitignore.
    gitignore: true,
  });

  const pkg = require(require.resolve(root("template/package.json")));

  // Set correct project name in package.json
  pkg.name = options.name;

  fs.writeFileSync(path.join(options.out, 'package.json'), JSON.stringify(pkg, null, 2), 'utf-8')

  // Remove yarn.lock.
  // It will be regenerated by yarn when installing.
  rimraf.sync(path.join(options.out, 'yarn.lock'));

  if (!Boolean(process.env.SKIP_SCRIPTS)) {
    execSync(`(cd ${q(options.out)} && yarn && yarn lint --fix && yarn typecheck)`, {
      stdio: 'inherit'
    });

    execSync(`CRP_ARG_OUT=${q(options.out)} CRP_ARG_NAME=${q(options.name)} yarn test`, {
      stdio: 'inherit'
    });
  }
}
